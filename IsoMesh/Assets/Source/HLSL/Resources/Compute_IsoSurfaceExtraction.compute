#pragma kernel Isosurface_Map
#pragma kernel Isosurface_GenerateVertices
#pragma kernel Isosurface_NumberVertices
#pragma kernel Isosurface_GenerateTriangles
#pragma kernel Isosurface_BuildIndexBuffer
#pragma kernel Isosurface_AddIntermediateVerticesToIndexBuffer

#include "../Common.hlsl"
#include "../QEFFunctions.cginc"
#include "../Compute_IsoSurfaceExtraction_Structs.hlsl"
#include "../MapSignedDistanceField.hlsl"

#define A_COORD x, y, z
#define B_COORD x + 1, y, z
#define C_COORD x, y + 1, z
#define D_COORD x + 1, y + 1, z
#define E_COORD x, y, z + 1
#define F_COORD x + 1, y, z + 1
#define G_COORD x, y + 1, z + 1
#define H_COORD x + 1, y + 1, z + 1

#define A 0
#define B 1
#define C 2
#define D 3
#define E 4
#define F 5
#define G 6
#define H 7

#define ISOSURFACE_EXTRACTION_TYPE__SURFACENETS 0
#define ISOSURFACE_EXTRACTION_TYPE__DUALCONTOURING 1

// counter buffer has 18 integers: [vertex count, 1, 1, triangle count, 1, 1, vertex count / 64, 1, 1, triangle count / 64, 1, 1, intermediate vertex count, 1, 1, intermediate vertex count / 64, 1, 1]
#define VERTEX_COUNT _Counter[0]
#define TRIANGLE_COUNT _Counter[3]
#define VERTEX_COUNT_DIV_64 _Counter[6]
#define TRIANGLE_COUNT_DIV_64 _Counter[9]
#define INTERMEDIATE_VERTEX_COUNT _Counter[12]
#define INTERMEDIATE_VERTEX_COUNT_DIV_64 _Counter[15]

static int edges[12][2] =
{
    {A, B},
    {A, C},
    {A, E},
    {B, D}, //      g-------h
    {B, F}, //     /|      /|
    {C, D}, //    / |     / |
    {C, G}, //   c--|----d  |
    {D, H}, //   |  e----|--f
    {E, F}, //   | /     | /
    {E, G}, //   a-------b
    {F, H},
    {G, H}
};


static float3 unitCorners[8] =
{
    float3(-1.0f, -1.0f, -1.0f), // A
    float3(1.0f, -1.0f, -1.0f), // B
    float3(-1.0f, 1.0f, -1.0f), // C
    float3(1.0f, 1.0f, -1.0f), // D
    float3(-1.0f, -1.0f, 1.0f), // E
    float3(1.0f, -1.0f, 1.0f), // F
    float3(-1.0f, 1.0f, 1.0f), // G
    float3(1.0f, 1.0f, 1.0f), // H
};

float _NudgeVerticesToAverageNormalScalar;
// how much to give vertices an extra push in the direction of the average normal of their cells edge intersections. combined with gradient descent, this can give better edges
float _NudgeMaxMagnitude;
// how much to give vertices an extra push in the direction of the average normal of their cells edge intersections. combined with gradient descent, this can give better edges
float _ConstrainToCellUnits;
// after QEF, the resulting vertex can be out of cell bounds. this controls how much leeway this gets before falling back to surface nets
int _BinarySearchIterations;
int _GradientDescentIterations;
float _VisualNormalSmoothing;
float _MaxAngleCosine;
// if the dot product of the vertex normal and the triangle cross product is less than this, we need to generate a new vertex with a new normal. this gives better normals at sharp edges
int _IsosurfaceExtractionType;

float4x4 _GroupTransform;

uint _PointsPerSide; // the amount of cells width, height, and depth. grid is always a cube
float _CellSize; // the width/height/depth of every individual cell. again, always a cube

RWStructuredBuffer<float> _Samples;
RWStructuredBuffer<int> _Counter;
RWStructuredBuffer<int> _BuildMeshIndirectArgs;
AppendStructuredBuffer<VertexData> _VertexDataPoints;

// 这段代码是用来将一个在三维网格中的点（x，y，z）转换为实际的顶点坐标。该函数命名为"CellCoordinateToVertex"，可能在像是将网格下的坐标映射到实际空间下的应用场景中使用。
// 让我们一段一段地来看这个代码：
// float gridSize = (float)(_PointsPerSide - 1.0); 这里定义一个名为gridSize的浮点型变量，它的值等于"_PointsPerSide"减1后的值，并转换为浮点类型。"_PointsPerSide"可能代表了网格在每个边上的点的数量。
// float bound = (gridSize / 2.0) * _CellSize; 这行代码定义了一个叫"bound"的变量，算出了网格每个边（长度为gridSize）的一半乘以"_CellSize"（可能代表每个网格单元的实际大小）后的结果，这个结果可能代表了从中心点到边缘的最大距离。
// 接下来的几行代码，利用lerp（线性插值）函数和saturate函数，将坐标值从网格坐标系转换到实际的顶点坐标系。
// float xPos = lerp(-bound, bound, saturate(x / gridSize));
// float yPos = lerp(-bound, bound, saturate(y / gridSize));
// float zPos = lerp(-bound, bound, saturate(z / gridSize));
// lerp函数的工作原理是根据第三个参数作为权重，返回第一个参数和第二个参数之间的插值。而saturate函数的作用是将参数的值限制在0和1之间。换句话说，lerp和saturate结合使用后，每个坐标都将映射至-bounded和bounded之间，相对于原始的网格的点坐标会在实际的空间内进行放大或者缩小。
// float3 untransformed = float3(xPos, yPos, zPos); 这里定义了一个名为untransformed的float3类型（可能是一个三维向量类型）变量，它的值等于xPos，yPos和zPos。
// return mul(_GroupTransform, float4(untransformed, 1.0)).xyz; 最后，代码通过乘以一个名为"_GroupTransform"的矩阵，来实现对untransformed的变换，得到经过旋转和/或者位移后的坐标位置，作为函数的输出结果。在这一步，float4(untransformed, 1.0)是将untransform的三维向量变为四维向量，这是为了方便应用仿射变换，比如旋转、平移等操作。
// 注意: 如果你正在Unity和C#环境下面工作，你需要用Unity的实现替换对应函数，因为lerp, saturate, mul, float3和float4在C#环境下是找不到的。这些在HLSL（High Level Shading Language）中常见，是计算机图形中的用语。

float3 CellCoordinateToVertex(int x, int y, int z)
{
    //float gridSize = (float)(_PointsPerSide - 1.0);
    float gridSize = (float)(_PointsPerSide);
    float bound = (gridSize / 2.0) * _CellSize;

    float xPos = lerp(-bound, bound, saturate(x / gridSize));
    float yPos = lerp(-bound, bound, saturate(y / gridSize));
    float zPos = lerp(-bound, bound, saturate(z / gridSize));

    float3 untransformed = float3(xPos, yPos, zPos);

    return mul(_GroupTransform, float4(untransformed, 1.0)).xyz;
}

float3 IndexToCellCoordinate(int index)
{
    int z = index / (_PointsPerSide * _PointsPerSide);
    index -= (z * _PointsPerSide * _PointsPerSide);
    int y = index / _PointsPerSide;
    int x = index % _PointsPerSide;

    return float3(x, y, z);
}

float3 IndexToVertex(int index)
{
    float3 coords = IndexToCellCoordinate(index);
    return CellCoordinateToVertex(coords.x, coords.y, coords.z);
}

int CellCoordinateToIndex(int x, int y, int z)
{
    return (x + y * _PointsPerSide + z * _PointsPerSide * _PointsPerSide);
}

[numthreads(4, 4, 4)]
void Isosurface_Map(uint3 id : SV_DispatchThreadID)
{
    int x = id.x;
    int y = id.y;
    int z = id.z;

    int index = CellCoordinateToIndex(x, y, z);

    float3 vertex = CellCoordinateToVertex(x, y, z);

    _Samples[index] = Map(vertex,x,y,z);
}

// 主要用于计算两点之间的交点，并通过二分搜索进行优化以提高精度。它的主要运用情况可能是用于计算图形渲染，特别是在游戏或3D模型中。
// 以下是该代码的解释：
// 方法接受6个参数，前四个是类型为 float 的 sample_from 和 sample_to，以及类型为 float3 的 localPoint_from 和 localPoint_to。此外，还有一个类型为 float3 的 localOrigin 参数。最后的 out float3 localIntersectionPoint 是输出参数，用于返回本地交点位置。
// 方法首先初始化输出参数 localIntersectionPoint 为 (0, 0, 0)。
// 接下来，通过检查 sample_from 和 sample_to 的符号是否相同来确定两个样本点是否在同一侧。如果它们在同一侧，则返回 false 并退出方法。
// 若 _BinarySearchIterations 小于或等于0，则将直接计算出交点并返回。计算公式为 t = sample_from / (sample_from - sample_to)，然后使用 lerp 函数（线性插值）获取交点。
// 若 _BinarySearchIterations 大于0，则进入二分搜索优化过程。首先，设置 localIntersectionPoint 为 localPoint_from 和 localPoint_to 的中点。然后，开始 _BinarySearchIterations 次循环，每次循环都更新 sample_new ，并根据 sample_new 的符号判断新点是在 sample_to 的同侧，还是在 sample_from 的同侧，并更新对应的样本和本地点，最后更新 localIntersectionPoint。
// 最后，方法返回 true。
// 需要注意的是，float3 是一个具有三个浮点数成员的数据类型，常用于表示3D空间中的向量或者点的位置。而 Map 函数在这段代码中没有定义，可能是计算某种特定映射的函数。
bool TryGetEdgeSurfaceIntersection(float sample_from, float sample_to, float3 localPoint_from, float3 localPoint_to,
                                   float3 localOrigin, out float3 localIntersectionPoint)
{
    localIntersectionPoint = float3(0, 0, 0);

    if (sign(sample_to) == sign(sample_from))
        return false;

    if (_BinarySearchIterations <= 0)
    {
        float t = sample_from / (sample_from - sample_to);
        localIntersectionPoint = lerp(localPoint_from, localPoint_to, t);
    }
    else
    {
        localIntersectionPoint = (localPoint_from + localPoint_to) * 0.5;

        [fastopt]
        for (int i = 0; i < _BinarySearchIterations; i++)
        {
            float sample_new = Map(localOrigin + localIntersectionPoint);
            if (sign(sample_to) == sign(sample_new)) // new point is on same side as sample_to
            {
                sample_to = sample_new;
                localPoint_to = localIntersectionPoint;
            }
            if (sign(sample_from) == sign(sample_new)) // new point is on same side as sample_from
            {
                sample_from = sample_new;
                localPoint_from = localIntersectionPoint;
            }

            localIntersectionPoint = (localPoint_from + localPoint_to) * 0.5;
        }
    }

    return true;
}

// 从代码来看，这段代码主要是在实现一种被称为"体素网格的平滑表面生成"的过程。
// 具体来说，该代码尝试从一个体素栅格生成一个平滑的表面，这在图形渲染，特别是对像地形或任何需要平滑表面的三维形状的渲染中非常有用。
// 函数 TryGetSurfacePoint 接受五个参数，两个是输出参数 surfacePoint 和 normal，它们分别表示表面上一点的位置和该点的精确法线，另外三个是输入参数 x、y、z，表示体素栅格中一个特定单元格的xyz坐标。
// vertices 数组存储的是体素单元格中 8 个顶点的指数。这些顶点根据 CellCoordinateToIndex 函数转换，在此基础上定义了一个物体是否处于表面。
// 这段代码首先通过检查体素单元格的每个顶点是否在表面上来确定该物体是否在表面上，这个检查是通过检查样本的符号和第一个顶点是否不同来完成的。如果它们中的任何一个有不同的符号，我们就知道我们在表面上有一个交叉点。
// 如果确定了物体位于表面上, 代码会进一步通过游走到每一条边并检查其是否与表面相交来计算表面的精确位置和法线。这通过判断每条边上的样本值的符号是否变化来完成。如果符号变化，则说明在该边上存在一个表面交叉点。
// 一旦所有的表面交叉点都被确定，代码会计算出一个平均交叉点，这个点是由所有交叉点的位置的平均值得到的。
// 最后，该程序使用梯度下降法来优化表面点的位置，同时通过 MapNormal 函数来计算表面点的精确法线。
// 总的来说，这个函数的功能是在体素栅格中找到并优化表面点的位置并计算相应的法线，这是在实现图形渲染时的一个重要步骤。
bool TryGetSurfacePoint(int x, int y, int z, out float3 surfacePoint, out int cubeIndex, out float3 normal)
{
    surfacePoint = float3(0, 0, 0);
    normal = float3(0, 0, 0);

    int vertices[8] =
    {
        CellCoordinateToIndex(A_COORD),
        CellCoordinateToIndex(B_COORD),
        CellCoordinateToIndex(C_COORD),
        CellCoordinateToIndex(D_COORD),

        CellCoordinateToIndex(E_COORD),
        CellCoordinateToIndex(F_COORD),
        CellCoordinateToIndex(G_COORD),
        CellCoordinateToIndex(H_COORD),
    };

    cubeIndex = vertices[A];
    float sign_A = sign(_Samples[cubeIndex]);

    bool isOnSurface = false;

    int maxIndex = (_PointsPerSide * _PointsPerSide * _PointsPerSide);

    // iterate over every vertex,
    // if the vertex is valid (not out of bounds) and its sign is different from the first vertex,
    // then this voxel contains surface
    // (note: i added vertex 'a' to the array, but i don't want to check it here because i checked it above while declaring 'isNegative', so i start at 1)

    // todo: can probably do this in the map kernel and just not dispatch on this cell at all
    [fastopt]
    for (int i = 1; i < 8; i++)
    {
        int index = vertices[i];
        isOnSurface = isOnSurface || (index < maxIndex && sign_A != sign(_Samples[index]));
    }

    if (!isOnSurface)
        return false;

    // if we're on the surface, we need to check each grid edge from this grid vertex to check whether it intersects the surface
    // we do this by checking whether the sign changes
    // for each of the 12 edges, if the sign changes on the distance value between each vertex, there is a surface intersection
    // at a point along the edge proportional to the change in distance
    // the cube surface point is the average of all the edge intersection points (in surface nets)
    // in dual contouring, the surface point is a vector which most closely approximates the point of intersection of all the planes
    // which intersect the edge intersection points and are tangent to their normals
    // ref: https://bonsairobo.medium.com/smooth-voxel-mapping-a-technical-deep-dive-on-real-time-surface-nets-and-texturing-ef06d0f8ca14
    //如果我们在表面上，我们需要检查这个网格顶点的每个网格边，以检查它是否与表面相交
    //我们通过检查符号是否改变来完成
    //对于12条边中的每一条，如果每个顶点之间的距离值的符号发生变化，则存在一个曲面相交
    //在沿边的某一点与距离的变化成正比
    //立方体表面点是所有边缘交点的平均值(在表面网中)
    //在对偶轮廓中，曲面点是最接近所有平面交点的矢量
    //与边交点相交并与其法线相切

    float halfCellSize = 0.5 * _CellSize;
    float3 localCellOrigin = IndexToVertex(vertices[A]) + float3(halfCellSize, halfCellSize, halfCellSize);

    int edgeIntersectionCount = 0;
    float3 averageEdgeIntersectionPoint = float3(0.0, 0.0, 0.0);
    float3 localEdgeIntersectionPoints[12];

    // iterate over each edge, checking if it intersects with the surface.
    [fastopt]
    for (int j = 0; j < 12; j++)
    {
        int from = edges[j][0];
        int to = edges[j][1];

        float sample_from = _Samples[vertices[from]];
        float sample_to = _Samples[vertices[to]];

        float3 localEdgeIntersectionPoint;
        if (TryGetEdgeSurfaceIntersection(sample_from, sample_to, unitCorners[from] * halfCellSize,
                                          unitCorners[to] * halfCellSize, localCellOrigin, localEdgeIntersectionPoint))
        {
            averageEdgeIntersectionPoint += localEdgeIntersectionPoint;
            localEdgeIntersectionPoints[edgeIntersectionCount++] = localEdgeIntersectionPoint;
        }
    }

    if (edgeIntersectionCount <= 0)
        return false;

    averageEdgeIntersectionPoint /= edgeIntersectionCount;

    float epsilon = _CellSize * 0.01;
    float3 localEdgeIntersectionNormals[12];

    [fastopt]
    for (int k = 0; k < edgeIntersectionCount; k++)
    {
        localEdgeIntersectionNormals[k] = MapNormal(localCellOrigin + localEdgeIntersectionPoints[k], epsilon);
    }

    if (_IsosurfaceExtractionType == ISOSURFACE_EXTRACTION_TYPE__SURFACENETS)
    {
        surfacePoint = localCellOrigin + averageEdgeIntersectionPoint;
    }
    else if (_IsosurfaceExtractionType == ISOSURFACE_EXTRACTION_TYPE__DUALCONTOURING)
    {
        surfacePoint = localCellOrigin + SolveQEF(edgeIntersectionCount, localEdgeIntersectionNormals,
                                                  localEdgeIntersectionPoints, averageEdgeIntersectionPoint);
    }

    for (int l = 0; l < _GradientDescentIterations; l++)
    {
        surfacePoint -= (MapNormal(surfacePoint, epsilon) * Map(surfacePoint));
    }

    normal = MapNormal(surfacePoint, _VisualNormalSmoothing);

    return true;
}

RWStructuredBuffer<CellData> _CellDataPoints;

// 这段代码是一个用于生成顶点的 HLSL 计算着色器内核。这个内核特别用于通过 Marching Cubes 算法生成体素表面的顶点，这种算法常常用于实现实时地形修改的游戏。
// 以下是代码的详细解释：
// 该内核以 [numthreads(4, 4, 4)] 注解标记，表示每个线程组中都有4x4x4个线程，即每个线程组有64个线程。
// Isosurface_GenerateVertices 方法接收 id 参数，其中 SV_DispatchThreadID 是系统值语义，表示发起这个线程的全局索引。
// x、y、z 的值从 id 的 x、y、z 分量中获取。
// result、normal 用于存储从 TryGetSurfacePoint 方法中获取的表面点和法线向量，index 和 cellData 用于存储索引和单元格数据。
// TryGetSurfacePoint 函数尝试获取一个在指定 x, y, z 位置的表面点。如果获取成功，则创建一个 VertexData 对象并填充数据，然后将这个数据插入 _VertexDataPoints 结构化缓冲区，并对 VERTEX_COUNT 进行原子加法操作；如果获取失败，则设置 cellData.SurfacePoint 为 (0, 0, 0)。
// 无论 TryGetSurfacePoint 是否成功，都将 cellData.VertexID 设置为 -1，然后将 cellData 存储到 _CellDataPoints 结构化缓冲器的 index 索引处。
// 最后，使用 InterlockedMax 将 VERTEX_COUNT / 64.0 向上取整并存储到 VERTEX_COUNT_DIV_64 中。
// 需要注意的是，InterlockedAdd 和 InterlockedMax 是原子操作的函数，可以在并行语境中安全地更新共享变量的值。
// 此函数可能在 HSL 的一个 Compute Shader（计算着色器）中，用于图形渲染过程中的并行计算。
// this kernel is dispatched per cell in the form x, y, z
[numthreads(4, 4, 4)]
void Isosurface_GenerateVertices(uint3 id : SV_DispatchThreadID)
{
    int x = id.x;
    int y = id.y;
    int z = id.z;

    float3 result;
    float3 normal;
    int index;
    CellData cellData;

    if (TryGetSurfacePoint(x, y, z, result, index, normal))
    {
        VertexData data;
        data.Index = 0; // will be set in next step
        data.CellID = index;
        data.Vertex = result;
        data.Normal = normal;

        cellData.SurfacePoint = result;

        _VertexDataPoints.Append(data);

        InterlockedAdd(VERTEX_COUNT, 1);
    }
    else
    {
        cellData.SurfacePoint = float3(0, 0, 0);
    }

    cellData.VertexID = -1; // will be set in next step
    _CellDataPoints[index] = cellData;

    // make sure 4th integer in counter is vertex count / 64, for use as an indirect args thread count
    InterlockedMax(VERTEX_COUNT_DIV_64, ceil(VERTEX_COUNT / 64.0));
}

RWStructuredBuffer<VertexData> _VertexDataPoints_Structured;
AppendStructuredBuffer<TriangleData> _TriangleDataPoints;

float4x4 _MeshTransform;

// called for each surface vertex, this kernel just tells each vertex its own index
[numthreads(64, 1, 1)]
void Isosurface_NumberVertices(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= ((uint)VERTEX_COUNT))
        return;

    VertexData data = _VertexDataPoints_Structured[id.x];

    // also use this step to apply an optional 'after the fact' transform.
    // this is used to offset undesirable unity hierarchy transforms, usually if data
    // will be sent back to the cpu
    data.Vertex = mul(_MeshTransform, float4(data.Vertex, 1.0)).xyz;
    data.Normal = mul(_MeshTransform, float4(data.Normal, 0.0)).xyz;

    data.Index = id.x;
    _VertexDataPoints_Structured[id.x] = data;

    _CellDataPoints[data.CellID].VertexID = id.x;
}

bool TryGetAdjacentCubesX(int x, int y, int z, out int cube0index, out int cube1index, out int cube2index,
                          out float edgeDist_A, out float edgeDist_B)
{
    cube0index = 0;
    cube1index = 0;
    cube2index = 0;

    edgeDist_A = 0.0;
    edgeDist_B = 0.0;

    // get the indices of the three (possible) cubes which share a common x axis
    cube0index = CellCoordinateToIndex(x, y, z - 1);
    cube1index = CellCoordinateToIndex(x, y - 1, z);
    cube2index = CellCoordinateToIndex(x, y - 1, z - 1);

    // return true if the common edge crosses the isosurface
    edgeDist_A = Map(CellCoordinateToVertex(x, y, z));
    edgeDist_B = Map(CellCoordinateToVertex(x + 1, y, z));

    return sign(edgeDist_A) != sign(edgeDist_B);
}

bool TryGetAdjacentCubesY(int x, int y, int z, out int cube0index, out int cube1index, out int cube2index,
                          out float edgeDist_A, out float edgeDist_C)
{
    cube0index = 0;
    cube1index = 0;
    cube2index = 0;

    edgeDist_A = 0.0;
    edgeDist_C = 0.0;

    // get the indices of the three (possible) cubes which share a common y axis
    cube0index = CellCoordinateToIndex(x - 1, y, z);
    cube1index = CellCoordinateToIndex(x, y, z - 1);
    cube2index = CellCoordinateToIndex(x - 1, y, z - 1);

    edgeDist_A = Map(CellCoordinateToVertex(x, y, z));
    edgeDist_C = Map(CellCoordinateToVertex(x, y + 1, z));

    return sign(edgeDist_A) != sign(edgeDist_C);
}

bool TryGetAdjacentCubesZ(int x, int y, int z, out int cube0index, out int cube1index, out int cube2index,
                          out float edgeDist_A, out float edgeDist_E)
{
    cube0index = 0;
    cube1index = 0;
    cube2index = 0;

    edgeDist_A = 0.0;
    edgeDist_E = 0.0;

    // get the indices of the three (possible) cubes which share a common z axis
    cube0index = CellCoordinateToIndex(x, y - 1, z);
    cube1index = CellCoordinateToIndex(x - 1, y, z);
    cube2index = CellCoordinateToIndex(x - 1, y - 1, z);

    edgeDist_A = Map(CellCoordinateToVertex(x, y, z));
    edgeDist_E = Map(CellCoordinateToVertex(x, y, z + 1));

    return sign(edgeDist_A) != sign(edgeDist_E);
}

void CreateTriangles(int a, int b, int c, int d, int e, int f, out TriangleData one, out TriangleData two)
{
    one.P_1 = a;
    one.P_2 = b;
    one.P_3 = c;

    two.P_1 = d;
    two.P_2 = e;
    two.P_3 = f;
}

// this functions takes a surface point index, the corresponding surface point, as well as the indices of the three adjacent cubes,
// and the distances at both ends of the 4 cubes common edge. when this method is called, it has already been confirmed that all 4
// cubes exist and contain surface points
void TryCreateTriangles(int index, float3 surfacePoint, int cube0, int cube1, int cube2, float edge1Dist,
                        float edge2Dist)
{
    CellData adjacentCell0 = _CellDataPoints[cube0];
    CellData adjacentCell1 = _CellDataPoints[cube1];
    CellData adjacentCell2 = _CellDataPoints[cube2];

    // check whether all three adjacent cubes have points on the surface
    if (adjacentCell0.HasSurfacePoint() && adjacentCell1.HasSurfacePoint() && adjacentCell2.HasSurfacePoint())
    {
        bool p1NegativeSide = edge1Dist < 0;
        bool p2NegativeSide = edge2Dist < 0;

        bool isNegativeFace = false;
        if (!p1NegativeSide && p2NegativeSide)
            isNegativeFace = true;

        // get the vertex index of the surface points
        int i_2 = adjacentCell0.VertexID;
        int i_3 = adjacentCell1.VertexID;
        int i_4 = adjacentCell2.VertexID;

        TriangleData one;
        TriangleData two;

        // split the quad along the shorter axis
        if (dot2(surfacePoint - adjacentCell2.SurfacePoint) < dot2(
            adjacentCell0.SurfacePoint - adjacentCell1.SurfacePoint))
        {
            if (isNegativeFace)
                CreateTriangles(index, i_2, i_4, index, i_4, i_3, one, two);
            else
                CreateTriangles(index, i_4, i_2, index, i_3, i_4, one, two);
        }
        else
        {
            if (isNegativeFace)
                CreateTriangles(i_2, i_4, i_3, index, i_2, i_3, one, two);
            else
                CreateTriangles(i_2, i_3, i_4, index, i_3, i_2, one, two);
        }

        _TriangleDataPoints.Append(one);
        _TriangleDataPoints.Append(two);
        InterlockedAdd(TRIANGLE_COUNT, 2);
    }
}

RWStructuredBuffer<float3> _MeshVertices;
RWStructuredBuffer<float3> _MeshNormals;
//RWStructuredBuffer<float2> _MeshUVs;
RWStructuredBuffer<float4> _MeshVertexColours;
RWStructuredBuffer<SDFMaterialGPU> _MeshVertexMaterials;
RWStructuredBuffer<int> _MeshTriangles;

RWStructuredBuffer<int> _ProceduralArgs;

// the purpose of this kernel is to generate up to 6 triangles (3 quads, one for each axis) 
// for each surface point (which will become the mesh vertices)
[numthreads(64, 1, 1)]
void Isosurface_GenerateTriangles(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= ((uint)VERTEX_COUNT))
        return;

    // index of the vertex being evaluated
    int i_1 = id.x;
    VertexData data = _VertexDataPoints_Structured[i_1];
    _MeshVertices[id.x] = data.Vertex;
    _MeshNormals[id.x] = data.Normal;
    //_MeshUVs[id.x] = MapUV(data.Vertex);

    SDFMaterialGPU mat = MapColour(data.Vertex);

    _MeshVertexMaterials[id.x] = mat;

    // we can use the vertex index to access the id number of the cell containing it,
    // and with that calculate the coordinate of the cell point
    int cellID = data.CellID;
    float3 surfacePoint = data.Vertex;

    float3 cellCoordinate = IndexToCellCoordinate(data.CellID);
    int x = cellCoordinate.x;
    int y = cellCoordinate.y;
    int z = cellCoordinate.z;

    if (x <= 1 || y <= 1 || z <= 1)
        return;

    int bounds = _PointsPerSide - 1;

    //if (x >= bounds || y >= bounds || z >= bounds)
    //    return;

    int cube0;
    int cube1;
    int cube2;

    float edge1Dist;
    float edge2Dist;

    // X AXIS
    if (TryGetAdjacentCubesX(x, y, z, cube0, cube1, cube2, edge1Dist, edge2Dist))
        TryCreateTriangles(i_1, surfacePoint, cube0, cube1, cube2, edge1Dist, edge2Dist);

    // Y AXIS
    if (TryGetAdjacentCubesY(x, y, z, cube0, cube1, cube2, edge1Dist, edge2Dist))
        TryCreateTriangles(i_1, surfacePoint, cube0, cube1, cube2, edge1Dist, edge2Dist);

    // Z AXIS
    if (TryGetAdjacentCubesZ(x, y, z, cube0, cube1, cube2, edge1Dist, edge2Dist))
        TryCreateTriangles(i_1, surfacePoint, cube0, cube1, cube2, edge1Dist, edge2Dist);

    // make sure 7th integer in counter is (triangle count - 1) / 64, for use as an indirect args thread count
    // note: i subtract 1 because previously i wanted the triangle count to bottom out at 1, not 0, because 0 in an indirect dispatch call is invalid
    InterlockedMax(TRIANGLE_COUNT_DIV_64, ceil(TRIANGLE_COUNT / 64.0));

    // setting indirect args for procedural drawing
    InterlockedMax(_ProceduralArgs[0], TRIANGLE_COUNT * 3);
}

AppendStructuredBuffer<NewVertexData> _IntermediateVertexBuffer;
StructuredBuffer<TriangleData> _TriangleDataPoints_Structured;

// dispatched for each triangle, this kernel unpacks the triangle data structs
// and lays them out sequentially
[numthreads(64, 1, 1)]
void Isosurface_BuildIndexBuffer(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= ((uint)TRIANGLE_COUNT))
        return;

    TriangleData data = _TriangleDataPoints_Structured[id.x];

    int index_1 = data.P_1;
    int index_2 = data.P_2;
    int index_3 = data.P_3;

    VertexData a = _VertexDataPoints_Structured[index_1];
    VertexData b = _VertexDataPoints_Structured[index_2];
    VertexData c = _VertexDataPoints_Structured[index_3];

    float3 v_a = a.Vertex;
    float3 v_b = b.Vertex;
    float3 v_c = c.Vertex;

    float3 n_a = a.Normal;
    float3 n_b = b.Normal;
    float3 n_c = c.Normal;

    float3 crossNormal = normalize(cross(v_b - v_a, v_c - v_a));

    if (saturate(dot(n_a, crossNormal)) < _MaxAngleCosine)
    {
        NewVertexData newVertex;
        newVertex.Index = id.x * 3 + 0;
        newVertex.Vertex = v_a;
        newVertex.Normal = crossNormal;

        InterlockedAdd(INTERMEDIATE_VERTEX_COUNT, 1);

        _IntermediateVertexBuffer.Append(newVertex);
    }

    if (saturate(dot(n_b, crossNormal)) < _MaxAngleCosine)
    {
        NewVertexData newVertex;
        newVertex.Index = id.x * 3 + 1;
        newVertex.Vertex = v_b;
        newVertex.Normal = crossNormal;

        InterlockedAdd(INTERMEDIATE_VERTEX_COUNT, 1);

        _IntermediateVertexBuffer.Append(newVertex);
    }

    if (saturate(dot(n_c, crossNormal)) < _MaxAngleCosine)
    {
        NewVertexData newVertex;
        newVertex.Index = id.x * 3 + 2;
        newVertex.Vertex = v_c;
        newVertex.Normal = crossNormal;

        InterlockedAdd(INTERMEDIATE_VERTEX_COUNT, 1);

        _IntermediateVertexBuffer.Append(newVertex);
    }

    _MeshTriangles[id.x * 3 + 0] = index_1;
    _MeshTriangles[id.x * 3 + 1] = index_2;
    _MeshTriangles[id.x * 3 + 2] = index_3;

    SDFMaterialGPU material_1 = _MeshVertexMaterials[index_1];
    SDFMaterialGPU material_2 = _MeshVertexMaterials[index_2];
    SDFMaterialGPU material_3 = _MeshVertexMaterials[index_3];

    _MeshVertexColours[index_1] = float4(material_1.Colour, material_1.Metallic);
    _MeshVertexColours[index_2] = float4(material_2.Colour, material_2.Metallic);
    _MeshVertexColours[index_3] = float4(material_3.Colour, material_3.Metallic);

    InterlockedMax(INTERMEDIATE_VERTEX_COUNT_DIV_64, ceil(INTERMEDIATE_VERTEX_COUNT / 64.0));
}

StructuredBuffer<NewVertexData> _IntermediateVertexBuffer_Structured;

// this is an optional final step which switches out some of the mesh vertices for newly generated ones
// in order to achieve sharp edges (according to a specified angle threshold)
[numthreads(64, 1, 1)]
void Isosurface_AddIntermediateVerticesToIndexBuffer(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= ((uint)INTERMEDIATE_VERTEX_COUNT))
        return;

    NewVertexData newVertex = _IntermediateVertexBuffer_Structured[id.x];

    int index = VERTEX_COUNT + id.x;

    //float2 uv = _MeshUVs[_MeshTriangles[newVertex.Index]];
    SDFMaterialGPU material = _MeshVertexMaterials[_MeshTriangles[newVertex.Index]];

    _MeshTriangles[newVertex.Index] = index;
    _MeshVertices[index] = newVertex.Vertex;
    _MeshNormals[index] = newVertex.Normal;
    //_MeshUVs[index] = uv;
    _MeshVertexMaterials[index] = material;
    _MeshVertexColours[index] = float4(material.Colour, material.Metallic);

    // doing this will mess with the vertex counts above in a race condition
    //InterlockedAdd(VERTEX_COUNT, 1);
    //InterlockedMax(VERTEX_COUNT_DIV_64, ceil(VERTEX_COUNT / 64.0));
}
